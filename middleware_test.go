package golexa_test

import (
	"context"
	"errors"
	"testing"

	"github.com/robsignorelli/golexa"
	"github.com/stretchr/testify/suite"
)

func TestMiddlewareSuite(t *testing.T) {
	suite.Run(t, new(MiddlewareSuite))
}

type MiddlewareSuite struct {
	suite.Suite
	fooHandler  golexa.HandlerFunc
	passThrough golexa.MiddlewareFunc
}

func (suite *MiddlewareSuite) SetupTest() {
	suite.fooHandler = func(_ context.Context, req golexa.Request) (golexa.Response, error) {
		return golexa.NewResponse(req).Speak("Foo").Ok()
	}
	suite.passThrough = func(ctx context.Context, request golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		return next(ctx, request)
	}
}

func (suite MiddlewareSuite) TestEmptyChain() {
	handler := golexa.Middleware{}.Then(suite.fooHandler)

	res, err := handler(context.TODO(), golexa.NewIntentRequest("Foo", golexa.NewSlots()))
	suite.NoError(err,
		"Should not have an error if the final handler did not have an error")
	suite.Equal("<speak>Foo</speak>", res.Body.OutputSpeech.SSML,
		"Should return the same response supplied by the final handler")
}

func (suite MiddlewareSuite) TestChain() {
	var checkpoints []string

	// Before and after the rest of the chain
	mw1 := func(ctx context.Context, request golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		checkpoints = append(checkpoints, "Before1")
		res, err := next(ctx, request)
		checkpoints = append(checkpoints, "After1")
		return res, err
	}

	// Only before the rest of the chain
	mw2 := func(ctx context.Context, request golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		checkpoints = append(checkpoints, "Before2")
		return next(ctx, request)
	}

	// Before and after the rest of the chain
	mw3 := func(ctx context.Context, request golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		res, err := next(ctx, request)
		checkpoints = append(checkpoints, "After3")
		return res, err
	}

	handler := golexa.Middleware{mw1, mw2, mw3}.Then(suite.fooHandler)

	res, err := handler(context.TODO(), golexa.NewIntentRequest("Foo", golexa.NewSlots()))
	suite.NoError(err,
		"Should not have an error if the final handler did not have an error")
	suite.Equal("<speak>Foo</speak>", res.Body.OutputSpeech.SSML,
		"Should return the same response supplied by the final handler")

	suite.Require().Len(checkpoints, 4,
		"Should allow middleware to inject behavior before and/or after 'next'")
	suite.Equal("Before1", checkpoints[0],
		"Middleware should execute in the order they were defined")
	suite.Equal("Before2", checkpoints[1],
		"Middleware should execute in the order they were defined")
	suite.Equal("After3", checkpoints[2],
		"Middleware should execute in the order they were defined")
	suite.Equal("After1", checkpoints[3],
		"Middleware should execute in the order they were defined")
}

func (suite MiddlewareSuite) TestShortCircuit() {
	mw1 := func(ctx context.Context, req golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		return golexa.NewResponse(req).Speak("Woof!").Ok()
	}

	// Include some extra nop handlers so that we are sure ANY middleware can do this.
	handler := golexa.Middleware{suite.passThrough, suite.passThrough, mw1, suite.passThrough}.Then(suite.fooHandler)

	res, err := handler(context.TODO(), golexa.NewIntentRequest("Foo", golexa.NewSlots()))
	suite.NoError(err,
		"Should not have an error middleware returned a valid response")
	suite.Equal("<speak>Woof!</speak>", res.Body.OutputSpeech.SSML,
		"Should return the same response provided by the short-circuiting middleware")
}

func (suite MiddlewareSuite) TestError() {
	mw1 := func(ctx context.Context, req golexa.Request, next golexa.HandlerFunc) (golexa.Response, error) {
		return golexa.Response{}, errors.New("nope")
	}

	// Include some extra nop handlers so that we are sure ANY middleware can do this.
	handler := golexa.Middleware{suite.passThrough, suite.passThrough, mw1, suite.passThrough}.Then(suite.fooHandler)

	_, err := handler(context.TODO(), golexa.NewIntentRequest("Foo", golexa.NewSlots()))
	suite.Error(err,
		"Should result in the same error generated by the failed middleware")
	suite.Equal("nope", err.Error(),
		"Should result in the same error generated by the failed middleware")
}
